/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;const h = __webpack_require__(/*! ./lib/hangul */ \"./src/lib/hangul.js\");\n\n(function () {\n  var TextTypingAnimation = (function () {\n    var defaultOptions = {\n      delay: 100,\n      duration: null,\n      append: false\n    };\n\n    var TYPE_GO = 0;\n    var TYPE_BACK = 1;\n    var TYPE_DELAY = 2;\n    var TYPE_CLEAR = 3;\n\n    function TextTypingAnimation(element) {\n      this._init(element);\n    }\n\n    function calcDelayByDuration(duration, textLen) {\n      return duration / textLen;\n    }\n\n    function writeText(writeTextArr) {\n      var that = this;\n      var element = this.element;\n      var step = this.step[0];\n      var delay = step.delay;\n      var duration = step.duration;\n\n      var writeTextArrLen = writeTextArr.length;\n      if (writeTextArrLen > 0) {\n        if (duration) {\n          delay = calcDelayByDuration(duration, writeTextArrLen);\n        }\n\n        var count = 0;\n        var interval = setInterval(function () {\n          element.innerHTML = writeTextArr[count].replace(/\\n/gi, '<br>');\n          count++;\n          \n          if (count === writeTextArrLen) {\n            clearInterval(interval);\n            that.step.shift();\n            that._isProceccing = false;\n            that.text = element.innerHTML.replace(/(<br>)/gm, '\\n');\n            execute.call(that);\n          }\n        }, delay);\n      }\n    }\n\n    function execute() {\n      var _isProceccing = this._isProceccing;\n      if (_isProceccing || this.step.length === 0) return false;\n\n      this._isProceccing = true;\n      var type = this.step[0].type;\n\n      switch(type) {\n        case TYPE_GO: \n          go.call(this);\n          break;\n        case TYPE_BACK:\n          back.call(this);\n          break;\n        case TYPE_DELAY:\n          delay.call(this);\n          break;\n        case TYPE_CLEAR:\n          clear.call(this);\n          break;\n      }\n    }\n\n    function go() {\n      var step = this.step[0];\n      var isAppend = step.append;\n      var strs;\n      var writeTextArr = [];\n      if (typeof step === 'string')\n        strs = step;\n      else {\n        strs = step.text;\n      }\n      \n      var strSplit= strs.split('\\n');\n      var newStrList = [];\n      strSplit.forEach(function (str) {\n        newStrList.push(h.disassemble(str, true));\n      });\n\n      var newStr = isAppend === true ? this.text : '';\n      for (var i = 0, newStrListLen = newStrList.length; i < newStrListLen; i++) {\n        var cvsList = newStrList[i];\n\n        if (i !== 0) {\n          newStr += '<br>';\n        }\n\n        for (var j = 0, cvsListLen = cvsList.length; j < cvsListLen; j++) {\n          var cvsItem = cvsList[j];\n          var char = '';\n\n          for (var k = 0, cvsItemLen = cvsItem.length; k < cvsItemLen; k++) {\n            char = h.assemble(cvsItem.slice(0, k + 1));\n            var tmpStr = newStr + char;\n            writeTextArr.push(tmpStr);\n          }\n          \n          newStr += char;\n        }\n      }\n\n      writeText.call(this, writeTextArr);\n    }\n\n    function back() {\n      var step = this.step[0];\n      var strs;\n      var writeTextArr = [];\n      if (typeof step === 'string')\n        strs = step;\n      else {\n        strs = step.text;\n      }\n      \n      var strSplit = strs.split('\\n');\n      var newStrList = [];\n      strSplit.forEach(function (str) {\n        newStrList.push(h.disassemble(str, true));\n      });\n\n      for (var i = newStrList.length - 1; i >= 0; i--) {\n        var maintainStr = this.text.substring(0, this.text.indexOf(strSplit[i]));\n        var cvsList = newStrList[i];\n\n        for (var j = cvsList.length - 1; j >= 0; j--) {\n          var cvsItem = cvsList[j];\n          var char = '';\n          var substringText = strSplit[i].substring(0, j);\n\n          for (var k = cvsItem.length - 1; k >= 0; k--) {\n            char = h.assemble(cvsItem.slice(0, k));\n            var tmpStr = maintainStr + substringText + char;\n\n            if (i === newStrList.length - 1 && j === cvsList.length - 1)\n              writeTextArr.push(tmpStr);\n            else if (k === 0) {\n              writeTextArr.push(tmpStr);\n            }\n          }\n        }\n      }\n\n      writeText.call(this, writeTextArr);\n    }\n\n    function delay() {\n      var that = this;\n      var step = this.step[0];\n      var delay = step.delay;\n\n      setTimeout(function () {\n        that.step.shift();\n        that._isProceccing = false;\n        execute.call(that);\n      }, delay);\n    }\n\n    function clear() {\n      this.step.shift();\n      this.text = '';\n      this.element.innerHTML = '';\n      this._isProceccing = false;\n      execute.call(this);\n    }\n\n    TextTypingAnimation.prototype._init = function (element) {\n      this.element = element;\n      this.step = [];\n      this.text = '';\n      this._isProceccing = false;\n    };\n\n    TextTypingAnimation.prototype._initStep = function (obj) {\n      var step = {\n        delay: obj.delay || defaultOptions.delay,\n        duration: obj.duration || defaultOptions.duration,\n        append: obj.append || defaultOptions.append,\n        text: obj.text,\n        type: obj.type\n      };\n\n      this.step.push(step);\n      execute.call(this);\n    };\n\n    TextTypingAnimation.prototype.go = function (obj) {\n      obj.type = TYPE_GO;\n      this._initStep(obj);\n      return this;\n    };\n\n    TextTypingAnimation.prototype.back = function (obj) {\n      obj.type = TYPE_BACK;\n      this._initStep(obj);\n      return this;\n    };\n\n    TextTypingAnimation.prototype.delay = function (delay) {\n      obj = { \n        type: TYPE_DELAY,\n        delay: delay\n      };\n      this._initStep(obj);\n      return this;\n    };\n\n    TextTypingAnimation.prototype.clear = function () {\n      obj = { \n        type: TYPE_CLEAR\n      };\n      this._initStep(obj);\n      return this;\n    };\n\n    return TextTypingAnimation;\n  })();\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n      return TextTypingAnimation;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n  \n  if (window)\n    window.TextTypingAnimation = TextTypingAnimation;\n})();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lib/hangul.js":
/*!***************************!*\
  !*** ./src/lib/hangul.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Hangul.js\n * https://github.com/e-/Hangul.js\n *\n * Copyright 2017, Jaemin Jo\n * under the MIT license.\n */\n\n(function(){\n  'use strict';\n  var CHO = [\n        'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ',\n        'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ',\n        'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ',\n        'ㅍ', 'ㅎ'\n      ],\n      JUNG = [\n        'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ',\n        'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', ['ㅗ', 'ㅏ'], ['ㅗ', 'ㅐ'],\n        ['ㅗ', 'ㅣ'], 'ㅛ', 'ㅜ', ['ㅜ','ㅓ'], ['ㅜ','ㅔ'], ['ㅜ','ㅣ'],\n        'ㅠ', 'ㅡ', ['ㅡ', 'ㅣ'], 'ㅣ'\n      ],\n      JONG = [\n        '', 'ㄱ', 'ㄲ', ['ㄱ','ㅅ'], 'ㄴ', ['ㄴ','ㅈ'], ['ㄴ', 'ㅎ'], 'ㄷ', 'ㄹ',\n        ['ㄹ', 'ㄱ'], ['ㄹ','ㅁ'], ['ㄹ','ㅂ'], ['ㄹ','ㅅ'], ['ㄹ','ㅌ'], ['ㄹ','ㅍ'], ['ㄹ','ㅎ'], 'ㅁ',\n        'ㅂ', ['ㅂ','ㅅ'], 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'\n      ],\n      HANGUL_OFFSET = 0xAC00,\n      CONSONANTS = [\n        'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄸ',\n        'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ',\n        'ㅁ', 'ㅂ', 'ㅃ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ',\n        'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'\n      ],\n      COMPLETE_CHO = [\n        'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ',\n        'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ',\n        'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'\n      ],\n      COMPLETE_JUNG = [\n        'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ',\n        'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ',\n        'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ',\n        'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'\n      ],\n      COMPLETE_JONG = [\n        '', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ',\n        'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ',\n        'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'\n      ],\n      COMPLEX_CONSONANTS = [\n        ['ㄱ','ㅅ','ㄳ'],\n        ['ㄴ','ㅈ','ㄵ'],\n        ['ㄴ','ㅎ','ㄶ'],\n        ['ㄹ','ㄱ','ㄺ'],\n        ['ㄹ','ㅁ','ㄻ'],\n        ['ㄹ','ㅂ','ㄼ'],\n        ['ㄹ','ㅅ','ㄽ'],\n        ['ㄹ','ㅌ','ㄾ'],\n        ['ㄹ','ㅍ','ㄿ'],\n        ['ㄹ','ㅎ','ㅀ'],\n        ['ㅂ','ㅅ','ㅄ']\n      ],\n      COMPLEX_VOWELS = [\n        ['ㅗ','ㅏ','ㅘ'],\n        ['ㅗ','ㅐ','ㅙ'],\n        ['ㅗ','ㅣ','ㅚ'],\n        ['ㅜ','ㅓ','ㅝ'],\n        ['ㅜ','ㅔ','ㅞ'],\n        ['ㅜ','ㅣ','ㅟ'],\n        ['ㅡ','ㅣ','ㅢ']\n      ],\n      CONSONANTS_HASH,\n      CHO_HASH,\n      JUNG_HASH,\n      JONG_HASH,\n      COMPLEX_CONSONANTS_HASH,\n      COMPLEX_VOWELS_HASH\n    ;\n\n  function _makeHash(array){\n    var length = array.length,\n        hash = {0 : 0}\n      ;\n    for (var i = 0; i < length; i++) {\n      if(array[i])\n        hash[array[i].charCodeAt(0)] = i;\n    }\n    return hash;\n  }\n\n  CONSONANTS_HASH = _makeHash(CONSONANTS);\n  CHO_HASH = _makeHash(COMPLETE_CHO);\n  JUNG_HASH = _makeHash(COMPLETE_JUNG);\n  JONG_HASH = _makeHash(COMPLETE_JONG);\n\n  function _makeComplexHash(array){\n    var length = array.length,\n        hash = {},\n        code1,\n        code2\n      ;\n    for (var i = 0; i < length; i++) {\n      code1 = array[i][0].charCodeAt(0);\n      code2 = array[i][1].charCodeAt(0);\n      if (typeof hash[code1] === 'undefined') {\n        hash[code1] = {};\n      }\n      hash[code1][code2] = array[i][2].charCodeAt(0);\n    }\n    return hash;\n  }\n\n  COMPLEX_CONSONANTS_HASH = _makeComplexHash(COMPLEX_CONSONANTS);\n  COMPLEX_VOWELS_HASH = _makeComplexHash(COMPLEX_VOWELS);\n\n  function _isConsonant(c) {\n    return typeof CONSONANTS_HASH[c] !== 'undefined';\n  }\n\n  function _isCho(c){\n    return typeof CHO_HASH[c] !== 'undefined';\n  }\n\n  function _isJung(c){\n    return typeof JUNG_HASH[c] !== 'undefined';\n  }\n\n  function _isJong(c){\n    return typeof JONG_HASH[c] !== 'undefined';\n  }\n\n  function _isHangul(c /* code number */){\n    return 0xAC00 <= c && c <= 0xd7a3;\n  }\n\n  function _isJungJoinable(a,b){\n    return (COMPLEX_VOWELS_HASH[a] && COMPLEX_VOWELS_HASH[a][b]) ? COMPLEX_VOWELS_HASH[a][b] : false;\n  }\n\n  function _isJongJoinable(a,b){\n    return COMPLEX_CONSONANTS_HASH[a] && COMPLEX_CONSONANTS_HASH[a][b] ? COMPLEX_CONSONANTS_HASH[a][b] : false;\n  }\n\n  var disassemble = function(string, grouped){\n    if (string === null) {\n      throw new Error('Arguments cannot be null');\n    }\n\n    if (typeof string === 'object') {\n      string = string.join('');\n    }\n\n    var result = [],\n        length = string.length,\n        cho,\n        jung,\n        jong,\n        code,\n        r\n      ;\n\n    for (var i = 0; i < length; i++) {\n      var temp = [];\n\n      code = string.charCodeAt(i);\n      if (_isHangul(code)) { // 완성된 한글이면\n        code -= HANGUL_OFFSET;\n        jong = code % 28;\n        jung = (code - jong) / 28 % 21;\n        cho = parseInt((code - jong) / 28 / 21);\n        temp.push(CHO[cho]);\n        if (typeof JUNG[jung] === 'object') {\n          temp = temp.concat(JUNG[jung]);\n        } else {\n          temp.push(JUNG[jung]);\n        }\n        if (jong > 0) {\n          if(typeof JONG[jong] === 'object') {\n            temp = temp.concat(JONG[jong]);\n          } else {\n            temp.push(JONG[jong]);\n          }\n        }\n      } else if (_isConsonant(code)) { //자음이면\n        if (_isCho(code)) {\n          r = CHO[CHO_HASH[code]];\n        } else {\n          r = JONG[JONG_HASH[code]];\n        }\n        if (typeof r === 'string') {\n          temp.push(r);\n        } else {\n          temp = temp.concat(r);\n        }\n      } else if (_isJung(code)) {\n        r = JUNG[JUNG_HASH[code]];\n        if (typeof r === 'string') {\n          temp.push(r);\n        } else {\n          temp = temp.concat(r);\n        }\n      } else {\n        temp.push(string.charAt(i));\n      }\n\n      if(grouped) result.push(temp);\n      else result = result.concat(temp);\n    }\n\n    return result;\n  };\n\n  var disassembleToString =  function(str) {\n    if (typeof str !== 'string') {\n      return '';\n    }\n    str = disassemble(str);\n    return str.join('');\n  };\n\n  var assemble = function(array){\n    if (typeof array === 'string') {\n      array = disassemble(array);\n    }\n\n    var result = [],\n        length = array.length,\n        code ,\n        stage = 0,\n        complete_index = -1, //완성된 곳의 인덱스\n        previous_code\n      ;\n\n    function _makeHangul(index){ // complete_index + 1부터 index까지를 greedy하게 한글로 만든다.\n      var code,\n          cho,\n          jung1,\n          jung2,\n          jong1 = 0,\n          jong2,\n          hangul = ''\n        ;\n      if (complete_index + 1 > index) {\n        return;\n      }\n      for (var step = 1; ; step++) {\n        if (step === 1) {\n          cho = array[complete_index + step].charCodeAt(0);\n          if (_isJung(cho)) { // 첫번째 것이 모음이면 1) ㅏ같은 경우이거나 2) ㅙ같은 경우이다\n            if (complete_index + step + 1 <= index && _isJung(jung1 = array[complete_index + step + 1].charCodeAt(0))) { //다음것이 있고 모음이면\n              result.push(String.fromCharCode(_isJungJoinable(cho, jung1)));\n              complete_index = index;\n              return;\n            } else {\n              result.push(array[complete_index + step]);\n              complete_index = index;\n              return;\n            }\n          } else if (!_isCho(cho)) {\n            result.push(array[complete_index + step]);\n            complete_index = index;\n            return;\n          }\n          hangul = array[complete_index + step];\n        } else if (step === 2) {\n          jung1 = array[complete_index + step].charCodeAt(0);\n          if (_isCho(jung1)) { //두번째 또 자음이 오면 ㄳ 에서 ㅅ같은 경우이다\n            cho = _isJongJoinable(cho, jung1);\n            hangul = String.fromCharCode(cho);\n            result.push(hangul);\n            complete_index = index;\n            return;\n          } else {\n            hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + HANGUL_OFFSET);\n          }\n        } else if (step === 3) {\n          jung2 = array[complete_index + step].charCodeAt(0);\n          if (_isJungJoinable(jung1, jung2)) {\n            jung1 = _isJungJoinable(jung1, jung2);\n          } else {\n            jong1 = jung2;\n          }\n          hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + JONG_HASH[jong1] + HANGUL_OFFSET);\n        } else if (step === 4) {\n          jong2 = array[complete_index + step].charCodeAt(0);\n          if (_isJongJoinable(jong1, jong2)) {\n            jong1 = _isJongJoinable(jong1, jong2);\n          } else {\n            jong1 = jong2;\n          }\n          hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + JONG_HASH[jong1] + HANGUL_OFFSET);\n        } else if (step === 5) {\n          jong2 = array[complete_index + step].charCodeAt(0);\n          jong1 = _isJongJoinable(jong1, jong2);\n          hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + JONG_HASH[jong1] + HANGUL_OFFSET);\n        }\n\n        if (complete_index + step >= index) {\n          result.push(hangul);\n          complete_index = index;\n          return;\n        }\n      }\n    }\n\n    for (var i = 0 ; i < length ; i++) {\n      code = array[i].charCodeAt(0);\n      if (!_isCho(code) && !_isJung(code) && !_isJong(code)){ //초, 중, 종성 다 아니면\n        _makeHangul(i-1);\n        _makeHangul(i);\n        stage = 0;\n        continue;\n      }\n      //console.log(stage, array[i]);\n      if (stage === 0) { // 초성이 올 차례\n        if (_isCho(code)) { // 초성이 오면 아무 문제 없다.\n          stage = 1;\n        } else if (_isJung(code)) {\n          // 중성이오면 ㅐ 또는 ㅘ 인것이다. 바로 구분을 못한다. 따라서 특수한 stage인 stage4로 이동\n          stage = 4;\n        }\n      } else if (stage == 1) { //중성이 올 차례\n        if (_isJung(code)) { //중성이 오면 문제없음 진행.\n          stage = 2;\n        } else { //아니고 자음이오면 ㄻ같은 경우가 있고 ㄹㅋ같은 경우가 있다.\n          if (_isJongJoinable(previous_code, code)) {\n            // 합쳐질 수 있다면 ㄻ 같은 경우인데 이 뒤에 모음이 와서 ㄹ마 가 될수도 있고 초성이 올 수도 있다. 따라서 섣불리 완성할 수 없다. 이땐 stage5로 간다.\n            stage = 5;\n          } else { //합쳐질 수 없다면 앞 글자 완성 후 여전히 중성이 올 차례\n            _makeHangul(i-1);\n          }\n        }\n      } else if (stage == 2) { //종성이 올 차례\n        if (_isJong(code)) { //종성이 오면 다음엔 자음 또는 모음이 온다.\n          stage = 3;\n        } else if (_isJung(code)) { //그런데 중성이 오면 앞의 모음과 합칠 수 있는지 본다.\n          if (_isJungJoinable(previous_code, code)) { //합칠 수 있으면 여전히 종성이 올 차례고 그대로 진행\n          } else { // 합칠 수 없다면 오타가 생긴 경우\n            _makeHangul(i-1);\n            stage = 4;\n          }\n        } else { // 받침이 안되는 자음이 오면 ㄸ 같은 이전까지 완성하고 다시시작\n          _makeHangul(i-1);\n          stage = 1;\n        }\n      } else if (stage == 3) { // 종성이 하나 온 상태.\n        if (_isJong(code)) { // 또 종성이면 합칠수 있는지 본다.\n          if (_isJongJoinable(previous_code, code)) { //합칠 수 있으면 계속 진행. 왜냐하면 이번에 온 자음이 다음 글자의 초성이 될 수도 있기 때문\n          } else { //없으면 한글자 완성\n            _makeHangul(i-1);\n            stage = 1; // 이 종성이 초성이 되고 중성부터 시작\n          }\n        } else if (_isCho(code)) { // 초성이면 한글자 완성.\n          _makeHangul(i-1);\n          stage = 1; //이 글자가 초성이되므로 중성부터 시작\n        } else if (_isJung(code)) { // 중성이면 이전 종성은 이 중성과 합쳐지고 앞 글자는 받침이 없다.\n          _makeHangul(i-2);\n          stage = 2;\n        }\n      } else if (stage == 4) { // 중성이 하나 온 상태\n        if (_isJung(code)) { //중성이 온 경우\n          if(_isJungJoinable(previous_code, code)) { //이전 중성과 합쳐질 수 있는 경우\n            _makeHangul(i);\n            stage = 0;\n          } else { //중성이 왔지만 못합치는 경우. ㅒㅗ 같은\n            _makeHangul(i-1);\n          }\n        } else { // 아니면 자음이 온 경우.\n          _makeHangul(i-1);\n          stage = 1;\n        }\n      } else if (stage == 5) { // 초성이 연속해서 두개 온 상태 ㄺ\n        if (_isJung(code)) { //이번에 중성이면 ㄹ가\n          _makeHangul(i-2);\n          stage = 2;\n        } else {\n          _makeHangul(i-1);\n          stage = 1;\n        }\n      }\n      previous_code = code;\n    }\n    _makeHangul(i-1);\n    return result.join('');\n  };\n\n  var search = function(a, b){\n    var ad = disassemble(a).join(''),\n        bd = disassemble(b).join('')\n        ;\n\n    return ad.indexOf(bd);\n  };\n\n  var rangeSearch = function(haystack, needle){\n    var hex = disassemble(haystack).join(''),\n        nex = disassemble(needle).join(''),\n        grouped = disassemble(haystack, true),\n        re = new RegExp(nex, 'gi'),\n        indices = [],\n        result;\n\n    if(!needle.length) return [];\n\n    while((result = re.exec(hex))) {\n      indices.push(result.index);\n    }\n\n    function findStart(index) {\n      for(var i = 0, length = 0; i < grouped.length; ++i) {\n        length += grouped[i].length;\n        if(index < length) return i;\n      }\n    }\n\n    function findEnd(index) {\n      for(var i = 0, length = 0; i < grouped.length; ++i) {\n        length += grouped[i].length;\n        if(index + nex.length <= length) return i;\n      }\n    }\n\n    return indices.map(function(i) {\n      return [findStart(i), findEnd(i)];\n    });\n  };\n\n  function Searcher(string) {\n    this.string = string;\n    this.disassembled = disassemble(string).join('');\n  }\n\n  Searcher.prototype.search = function(string) {\n    return disassemble(string).join('').indexOf(this.disassembled);\n  };\n  var endsWithConsonant = function (string) {\n    if (typeof string === 'object') {\n      string = string.join('');\n    }\n\n    var code = string.charCodeAt(string.length - 1);\n\n    if (_isHangul(code)) { // 완성된 한글이면\n      code -= HANGUL_OFFSET;\n      var jong = code % 28;\n      if (jong > 0) {\n        return true;\n      }\n    } else if (_isConsonant(code)) { //자음이면\n      return true;\n    }\n    return false;\n  };\n\n  var endsWith = function (string, target) {\n    return disassemble(string).pop() === target;\n  };\n\n\n  var hangul = {\n    disassemble: disassemble,\n    d: disassemble, // alias for disassemble\n    disassembleToString: disassembleToString,\n    ds: disassembleToString, // alias for disassembleToString\n    assemble: assemble,\n    a: assemble, // alias for assemble\n    search: search,\n    rangeSearch: rangeSearch,\n    Searcher: Searcher,\n    endsWithConsonant: endsWithConsonant,\n    endsWith: endsWith,\n    isHangul: function(c){\n      if (typeof c === 'string')\n        c = c.charCodeAt(0);\n      return _isHangul(c);\n    },\n    isComplete: function(c){\n      if (typeof c === 'string')\n        c = c.charCodeAt(0);\n      return _isHangul(c);\n    },\n    isConsonant: function(c){\n      if (typeof c === 'string')\n        c = c.charCodeAt(0);\n      return _isConsonant(c);\n    },\n    isVowel: function(c){\n      if (typeof c === 'string')\n        c = c.charCodeAt(0);\n      return _isJung(c);\n    },\n    isCho: function(c){\n      if (typeof c === 'string')\n        c = c.charCodeAt(0);\n      return _isCho(c);\n    },\n    isJong: function(c){\n      if (typeof c === 'string')\n        c = c.charCodeAt(0);\n      return _isJong(c);\n    },\n    isHangulAll: function(str){\n      if (typeof str !== 'string') return false;\n      for (var i = 0; i < str.length; i++) {\n        if (!_isHangul(str.charCodeAt(i))) return false;\n      }\n      return true;\n    },\n    isCompleteAll: function(str){\n      if (typeof str !== 'string') return false;\n      for (var i = 0; i < str.length; i++) {\n        if (!_isHangul(str.charCodeAt(i))) return false;\n      }\n      return true;\n    },\n    isConsonantAll: function(str){\n      if (typeof str !== 'string') return false;\n      for (var i = 0; i < str.length; i++) {\n        if (!_isConsonant(str.charCodeAt(i))) return false;\n      }\n      return true;\n    },\n    isVowelAll: function(str){\n      if (typeof str !== 'string') return false;\n      for (var i = 0; i < str.length; i++) {\n        if (!_isJung(str.charCodeAt(i))) return false;\n      }\n      return true;\n    },\n    isChoAll: function(str){\n      if (typeof str !== 'string') return false;\n      for (var i = 0; i < str.length; i++) {\n        if (!_isCho(str.charCodeAt(i))) return false;\n      }\n      return true;\n    },\n    isJongAll: function(str){\n      if (typeof str !== 'string') return false;\n      for (var i = 0; i < str.length; i++) {\n        if (!_isJong(str.charCodeAt(i))) return false;\n      }\n      return true;\n    }\n  };\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n      return hangul;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})();\n\n//# sourceURL=webpack:///./src/lib/hangul.js?");

/***/ })

/******/ });